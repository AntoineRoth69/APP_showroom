import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np
import time
import paho.mqtt.client as mqtt
import matplotlib.animation as animation
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import normalize
from sklearn.decomposition import PCA
from sklearn import metrics
from sklearn.datasets import make_blobs
from sklearn import decomposition
from sklearn import datasets


# Successful Connection Callback
def on_connect(client, userdata, flags, rc):
    print('Connected with result code '+str(rc))
    client.subscribe('\showroom\Lidar')

tab=[]
# Message delivery callback
def on_message(client, userdata, msg):
    print(str(msg.payload.decode("utf-8")))
    #tab = append_limit(value, list)

def append_limit(value, list):
    newList = list
    if(len(list)>=300):
        del list[0]
    newList.append(value)
    #return newList

def getMesure(n): # n= nombre de mesure Ã  mettre dans res

    return res # res = [ [angle, distance],......., [angle, distance], [angle, distance],] de sorte que len (res)=n

client = mqtt.Client()

# Set callback handler
client.on_connect = on_connect
client.on_message = on_message

# Set up connection
client.connect('10.100.100.117', 443, 60)
# Publish message
client.publish('\showroom\Lidar',payload='SUR',qos=0)

client.loop_forever()




"""           Traitement des donnÃ©es          """
def PolarToCart(angle,distance):
    x = distance*np.cos(angle*((2*np.pi)/360))
    y = distance*np.sin(angle*((2*np.pi)/360))
    return [x,y]

def animate(i, xs, ys):
    # Limit x and y lists to 20 items
    #xs = xs[-20:]
    #ys = ys[-20:]

    # Draw x and y lists
    ax.clear()
    ax.scatter(xs, ys)

    # Format plot
    plt.xticks(rotation=45, ha='right')
    plt.subplots_adjust(bottom=0.30)
    plt.title('Lidar')
    plt.ylabel('Distance')

def dbscan(res):
    # Numpy array of all the cluster labels assigned to each data point
    res = np.array(res)
    std = StandardScaler()
    X = std.fit_transform(res)
    db = DBSCAN(eps=0.2, min_samples=20).fit(X)
    core_samples_mask = np.zeros_like(db.labels_, dtype=bool)
    core_samples_mask[db.core_sample_indices_] = True
    labels = db.labels_
    data = std.inverse_transform(X)
    # Number of clusters in labels, ignoring noise if present.
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    n_noise_ = list(labels).count(-1)
    # Black removed and is used for noise instead.
    unique_labels = set(labels)
    results, cart, temp = [], [], []
    for k in zip(unique_labels):
        class_member_mask = labels == k
        Scluster = std.inverse_transform(X[class_member_mask & core_samples_mask])
        results.append(Scluster)
       

        for i in results:
            for j in range(len(i)):
                a = PolarToCart(i[j][0], i[j][1])
                temp.append(a)
            temp = np.array(temp)
            cart.append(temp)
            temp = []
       
    return cart



"""
t= time.time()
plt.ion()
res=[]
while True:
    value = ???????????????????
    append_limit(value, res)
    points = dbscan(res)
    
    fig = plt.figure(1)
    ax = fig.add_subplot(1, 1, 1)
                
    for i in range(len(points)-1):   
        m = points[i]
        ax.scatter(m[:,0], m[:,1])
        fig.canvas.draw()
        ani = animation.FuncAnimation(fig, animate, fargs=(m[:, 0], m[:, 1]), interval=1000)
 

    if time.time()-t>120:
        break

"""















