import json
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np
import time
import paho.mqtt.client as mqtt
import matplotlib.animation as animation
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import normalize
from sklearn.decomposition import PCA
from sklearn import metrics
from sklearn.datasets import make_blobs
from sklearn import decomposition
from sklearn import datasets

# variable de comptage pour getMesure
nbValues = 0

# Successful Connection Callback
def on_connect(client, userdata, flags, rc):
    print('Connected with result code '+str(rc))
    client.subscribe('\showroom\Lidar')

tab=[]
# Message delivery callback
def on_message(client, userdata, msg):
    global nbValues
    message = str(msg.payload.decode("utf-8"))
    print(message)
    json_msg = json.loads(message)
    to_append=[]
    for json_obj in json_msg:
        keys = list(json_obj.keys())
        to_append.append(json_obj.get(keys[0]))
    tab.append(to_append)
    nbValues = nbValues + 1

def append_limit(value, list):
    if(len(list)>=15):
        del list[0]
    list.append(value)

def getMesure(n): # n= nombre de mesure Ã  mettre dans res
    # on ne prends les valeurs que lors de l'appel de la fonction
    client.loop_start()
    while True:
        if n==nbValues :
            break
    client.loop_stop()
    return tab # tab = [ [angle, distance],......., [angle, distance], [angle, distance],] de sorte que len (res)=n

client = mqtt.Client()

# Set callback handler
client.on_connect = on_connect
client.on_message = on_message

# Set up connection
client.connect('10.100.100.117', 443, 60)
# Publish message
client.publish('\showroom\Lidar',payload='SUR',qos=0)


# valeur en continu
#client.loop_forever()
print(getMesure(10))




"""           Traitement des donnÃ©es          """
def PolarToCart(angle,distance):
    x = distance*np.cos(angle*((2*np.pi)/360))
    y = distance*np.sin(angle*((2*np.pi)/360))
    return [x,y]

def animate(i, xs, ys):
    # Limit x and y lists to 20 items
    #xs = xs[-20:]
    #ys = ys[-20:]

    # Draw x and y lists
    ax.clear()
    ax.scatter(xs, ys)

    # Format plot
    plt.xticks(rotation=45, ha='right')
    plt.subplots_adjust(bottom=0.30)
    plt.title('Lidar')
    plt.ylabel('Distance')

def dbscan(res):
    # Numpy array of all the cluster labels assigned to each data point
    res = np.array(res)
    std = StandardScaler()
    X = std.fit_transform(res)
    db = DBSCAN(eps=0.2, min_samples=20).fit(X)
    core_samples_mask = np.zeros_like(db.labels_, dtype=bool)
    core_samples_mask[db.core_sample_indices_] = True
    labels = db.labels_
    data = std.inverse_transform(X)
    # Number of clusters in labels, ignoring noise if present.
    n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
    n_noise_ = list(labels).count(-1)
    # Black removed and is used for noise instead.
    unique_labels = set(labels)
    results, cart, temp = [], [], []
    for k in zip(unique_labels):
        class_member_mask = labels == k
        Scluster = std.inverse_transform(X[class_member_mask & core_samples_mask])
        results.append(Scluster)
       

        for i in results:
            for j in range(len(i)):
                a = PolarToCart(i[j][0], i[j][1])
                temp.append(a)
            temp = np.array(temp)
            cart.append(temp)
            temp = []
       
    return cart



"""
t= time.time()
plt.ion()
res=[]
while True:
    value = ???????????????????
    append_limit(value, res)
    points = dbscan(res)
    
    fig = plt.figure(1)
    ax = fig.add_subplot(1, 1, 1)
                
    for i in range(len(points)-1):   
        m = points[i]
        ax.scatter(m[:,0], m[:,1])
        fig.canvas.draw()
        ani = animation.FuncAnimation(fig, animate, fargs=(m[:, 0], m[:, 1]), interval=1000)
 

    if time.time()-t>120:
        break

"""















